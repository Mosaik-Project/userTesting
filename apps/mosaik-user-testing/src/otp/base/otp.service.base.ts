/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { PrismaService } from "../../prisma/prisma.service";
import { Prisma, Otp as PrismaOtp } from "@prisma/client";
import { OtpCreateInput } from "./OtpCreateInput";
import { Otp } from "./Otp";
import { DeleteOtpArgs } from "./DeleteOtpArgs";
import { OtpWhereUniqueInput } from "./OtpWhereUniqueInput";
import { GenerateEmailOtpInput } from "../GenerateEmailOtpInput";
import { GeneratePhoneOtpInput } from "../GeneratePhoneOtpInput";
import { OtpUpdateInput } from "./OtpUpdateInput";
import { VerifyEmailOtpInput } from "../VerifyEmailOtpInput";
import { VerifyPhoneOtpInput } from "../VerifyPhoneOtpInput";

export class OtpServiceBase {
  constructor(protected readonly prisma: PrismaService) {}

  async count(args: Omit<Prisma.OtpCountArgs, "select">): Promise<number> {
    return this.prisma.otp.count(args);
  }

  async otps(args: Prisma.OtpFindManyArgs): Promise<PrismaOtp[]> {
    return this.prisma.otp.findMany(args);
  }
  async otp(args: Prisma.OtpFindUniqueArgs): Promise<PrismaOtp | null> {
    return this.prisma.otp.findUnique(args);
  }
  async createOtp(args: Prisma.OtpCreateArgs): Promise<PrismaOtp> {
    return this.prisma.otp.create(args);
  }
  async updateOtp(args: Prisma.OtpUpdateArgs): Promise<PrismaOtp> {
    return this.prisma.otp.update(args);
  }
  async deleteOtp(args: Prisma.OtpDeleteArgs): Promise<PrismaOtp> {
    return this.prisma.otp.delete(args);
  }
  async CreateOtp(args: OtpCreateInput): Promise<Otp> {
    throw new Error("Not implemented");
  }
  async DeleteOtp(args: DeleteOtpArgs): Promise<Otp> {
    throw new Error("Not implemented");
  }
  async FindOtp(args: OtpWhereUniqueInput): Promise<Otp> {
    throw new Error("Not implemented");
  }
  async GenerateEmailOtp(args: GenerateEmailOtpInput): Promise<{ otp: string }> {
    const { email } = args;

    // Validate the email input
    if (!email) {
      throw new Error("Email is required");
    }

    // Generate a random 6-digit OTP
    const otpCode = Math.floor(100000 + Math.random() * 900000).toString();

    // Create OTP record using Prisma
    const otpRecord = await this.prisma.otp.create({
      data: {
        email: email,
        otp: otpCode,
        phone: null,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
    });
    if (!otpRecord.otp) {
      throw new Error("OTP generation failed, no OTP received");
    }
    // Return the generated OTP in the response
    return { otp: otpRecord.otp };
  }
  async GeneratePhoneOtp(args: GeneratePhoneOtpInput): Promise<string> {
    const { phoneNumber } = args;

    // Validate the phone input
    if (!phoneNumber) {
      throw new Error("Phone number is required");
    }

    // Generate a random 6-digit OTP
    const otpCode = Math.floor(100000 + Math.random() * 900000).toString();

    try {
      // Create OTP record using Prisma
      await this.prisma.otp.create({
        data: {
          email: null,
          phone: phoneNumber,
          otp: otpCode,
          createdAt: new Date(),
          updatedAt: new Date(),
        },
      });

      // Return the generated OTP
      return otpCode;
    } catch (error) {
      console.error("Error generating OTP:", error);
      throw new Error("Could not generate OTP. Please try again.");
    }
  }
  async UpdateOtp(args: OtpUpdateInput): Promise<Otp> {
    throw new Error("Not implemented");
  }
  async VerifyEmailOtp(args: VerifyEmailOtpInput): Promise<boolean> {
    const { email, otp } = args;

    // Validate the email and OTP inputs
    if (!email || !otp) {
      throw new Error("Email and OTP are required");
    }

    try {
      // Fetch the OTP record for the given email
      const otpRecord = await this.prisma.otp.findFirst({
        where: {
          email: email,
          otp: otp,
        },
      });

      // Check if the record exists and the OTP matches
      if (otpRecord) {
        // Optionally, you could also check if the OTP has expired, if you store expiration time
        // For now, just check if the OTP exists
        return true;
      } else {
        return false;
      }
    } catch (error) {
      console.error("Error verifying OTP:", error);
      throw new Error("Could not verify OTP. Please try again.");
    }
  }
  async VerifyPhoneOtp(args: VerifyPhoneOtpInput): Promise<boolean> {
    const { phoneNumber, otp } = args;

    // Validate the phoneNumber and OTP inputs
    if (!phoneNumber || !otp) {
      throw new Error("phoneNumber number and OTP are required");
    }

    try {
      // Fetch the OTP record for the given phoneNumber number
      const otpRecord = await this.prisma.otp.findFirst({
        where: {
          phone: phoneNumber,
          otp: otp,
        },
      });

      // Check if the record exists and the OTP matches
      if (otpRecord) {
        // Optionally, you could also check if the OTP has expired, if you store expiration time
        // For now, just check if the OTP exists
        return true;
      } else {
        return false;
      }
    } catch (error) {
      console.error("Error verifying OTP:", error);
      throw new Error("Could not verify OTP. Please try again.");
    }
  }
}
